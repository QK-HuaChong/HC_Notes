# Java

## JVM

### 1. 内存模型

- JVM内存模型

![JVM内存模型](img/jvm_01.jpg 'JVM内存模型')

- JMM内存模型：定义程序中变量的访问规则

![JVM内存模型](img/jvm_02.jpg 'JVM内存模型')

- JMM保证

![JVM内存模型](img/jvm_03.jpg 'JVM内存模型')

**注：** volatile

> volatile:1.对变量的赋值会强制刷新到主内存，强制变量的读取会从主内存中重新加载。2.阻止指令重排序

### 2. 类加载机制

#### 2.1、类加载的流程

![类加载](img/jvm_04.png '类加载流程')

#### 2.2、类加载器：

***双亲委派模式***

- BootStrap ClassLoader 启动类加载 --->  <JAVA_HOME>/lib
- ExtClassLoader 扩展加载器  --->  <JAVA_HOME>/lin/ext
- AppClassLoader 应用加载器   --->   java -classpath
- Custom ClassLoader 自定义类加载器

### 3. GC 垃圾回收

#### 3.1、分代回收

- 年轻代  （PSYoungGen）

![年轻代](img/jvm_06.png '年轻代')

>两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。

- 老年代  （ParOldGen）
- 元空间   [JDK1.8 之前 永久代 Perm]   （MetaSpace）

![堆内存](img/jvm_05.png '堆内存')

#### 3.2、回收算法

- CMS 算法
- G1 算法
- ZGC (JDK 1.11)

#### 3.3、FullGC的触发

- 1、年轻代晋升老年代空间不足
- 2、永久代空间不足

### 4. 性能调优

***目标:***

>使用较小的内存占用来获得较高的吞吐量或者较低的延迟

***方法***

- 线程池：解决用户响应时间长的问题
- 连接池
- JVM启动参数：调整各代的内存比例和垃圾回收算法，提高吞吐量
- 程序算法：改进程序逻辑算法提高性能

#### 4.1、JVM参数调优参考

- 为了防止垃圾收集器在最小（-Xms）、最大（-Xmx）之间收缩堆而产生额外的时间，我们通常把最大、最小设置为`相同的值`。
- 年轻代和年老代将根据默认的`比例（1：2）分配`堆内存
- 如何选择应该依赖应用程序对象生命周期的分布情况：`如果应用存在大量的临时对象，应该选择更大的年轻代`；`如果存在相对较多的持久对象，年老代应该适当增大`。

### 5. 编译器优化

### 6. 执行模式

## 并发和多线程

### 1. 死锁

#### 1.1、产生死锁的四个条件

### 2. 线程的状态转化

#### 2.1 线程的六种状态

- NEW
- RUNABLE
- BLOCKED
- TIME_WAITING
- WAITING
- TERMINATED

#### 2.2、 线程的六种状态转化

![线程](img/thread_01.png '线程状态转化')

### 3. 线程的同步和互斥

#### 3.1、CAS

#### 3.2、 Synchronized

### 4. 线程间通信

### 5. 线程池