# Java

## JVM

### 1. 内存模型

- JVM内存模型

![JVM内存模型](img/jvm_01.jpg 'JVM内存模型')

- JMM内存模型：定义程序中变量的访问规则

![JVM内存模型](img/jvm_02.jpg 'JVM内存模型')

- JMM保证

![JMM内存模型](img/jvm_03.jpg 'JMM内存模型')

- 原子性：基本数据类型的访问读写是具备原子性的，synchronized块之间的操作也具备原子性。
- 可见性：指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。synchronized(规则8)和final可以保证可见性。Final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去，那么在其他线程中就能看见final字段的值。
- 有序性：volatile本身包含了禁止指令重排序的语义，而synchronized则是由规则5获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

**注：** volatile

> volatile:1.对变量的赋值会强制刷新到主内存，强制变量的读取会从主内存中重新加载。2.阻止指令重排序

### 2. 类加载机制

#### 2.1、类加载的流程

![类加载](img/jvm_04.png '类加载流程')

#### 2.2、类加载器：

***双亲委派模式***

- BootStrap ClassLoader 启动类加载 --->  <JAVA_HOME>/lib
- ExtClassLoader 扩展加载器  --->  <JAVA_HOME>/lin/ext
- AppClassLoader 应用加载器   --->   java -classpath
- Custom ClassLoader 自定义类加载器

### 3. GC 垃圾回收

#### 3.1、分代回收

- 年轻代  （PSYoungGen）

![年轻代](img/jvm_06.png '年轻代')

>两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。

- 老年代  （ParOldGen）
- 元空间   [JDK1.8 之前 永久代 Perm]   （MetaSpace）

![堆内存](img/jvm_05.png '堆内存')

#### 3.2、回收算法

- CMS 算法
- G1 算法
- ZGC (JDK 1.11)

#### 3.3、FullGC的触发

- 1、年轻代晋升老年代空间不足
- 2、永久代空间不足

### 4. 性能调优

***目标:***

>使用较小的内存占用来获得较高的吞吐量或者较低的延迟

***方法***

- 线程池：解决用户响应时间长的问题
- 连接池
- JVM启动参数：调整各代的内存比例和垃圾回收算法，提高吞吐量
- 程序算法：改进程序逻辑算法提高性能

#### 4.1、JVM参数调优参考

- 为了防止垃圾收集器在最小（-Xms）、最大（-Xmx）之间收缩堆而产生额外的时间，我们通常把最大、最小设置为`相同的值`。
- 年轻代和年老代将根据默认的`比例（1：2）分配`堆内存
- 如何选择应该依赖应用程序对象生命周期的分布情况：`如果应用存在大量的临时对象，应该选择更大的年轻代`；`如果存在相对较多的持久对象，年老代应该适当增大`。

### 5. 编译器优化

### 6. 执行模式

## 并发和多线程

### 1. 死锁

#### 1.1、何为死锁：

>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。

#### 1.1、产生死锁的四个条件

- 互斥条件：

>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

- 不可剥夺条件:
  
>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。

- 请求与保持条件:

>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

- 循环等待条件:

>存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有

#### 1.2、处理死锁的方法：

- `预防死锁`：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。
- `避免死锁`：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。
- `检测死锁`：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。
- `解除死锁`：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。

### 相关博文

1. [死锁，死锁的四个必要条件以及处理策略](https://blog.csdn.net/wljliujuan/article/details/79614019)

### 2. 线程的状态转化

#### 2.1 线程的六种状态

- NEW
- RUNABLE
- BLOCKED
- TIME_WAITING
- WAITING
- TERMINATED

#### 2.2、 线程的六种状态转化

![线程](img/thread_01.png '线程状态转化')

### 3. 线程的同步和互斥

- 【同步】：

>是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中`协同步调`，`按预定的先后次序运行`。比如 A 任务的运行依赖于 B 任务产生的数据。

- 【互斥】：

>是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，`只能等到该任务运行完这个程序片段后才可以运行`。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。

#### 3.1、CAS

#### 3.2、 Synchronized

#### 3.3、 lock

### 4. 线程间通信

### 5. 线程池

## 数据结构与算法

### 数据结构

#### 1、队列

>先进先出

#### 2、栈

>后进先出

#### 3、表

- 数组
- 单链表
- 双链表
- 循环链表
- 散列表

#### 4、图

#### 5、树

- 定义：

>树（Tree）是n（n>=0)个结点的有限集。n=0时称为空树。

- 非空树：

1）有且`仅有一个`特定的称为`根（Root）`的结点；

2）当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、......、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。

3）n>0时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。

4）m>0时，子树的个数没有限制，但它们一定是互不相交的。

![树](img/tree_01.png '树')

- 结点的度

>结点`拥有的子树数目`称为结点的度。

- 树的遍历
  
  - 前序遍历
  >前序遍历通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。
  - 中序遍历
  >中序遍历就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。
  - 后序遍历
  >后序遍历就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。
  - 层序遍历
  >层次遍历就是按照树的层次自上而下的遍历二叉树

##### 5.1、二叉树

- 平衡二叉树
  >对一颗具有n个结点的二叉树按层编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
- 红黑树
  >
- 哈弗曼树
- 堆
  
##### 5.2、多叉树

- B树
- B+树
- 字典树

### 算法

#### 1、算法思路

#### 2、复杂度

- 空间复杂度
- 时间复杂度

#### 3、字符串匹配

#### 4、排序

#### 5、查找

## 中间件
